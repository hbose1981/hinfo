Your workflow is **feasible** and addresses many challenges commonly encountered during major Chef client upgrades. Here’s a breakdown of strengths, risk points, and recommended safety additions:

***

## **Strengths of Your Approach**

- **Automated, non-destructive testing:**  
  By running a dry-run (`--why-run`) on Chef 18.5 first, you detect possible failures without altering system state, making it safe for initial diagnostics.

- **Full log capture:**  
  Capturing the debug log gives rich insight for troubleshooting and root-cause analysis, especially for complex cookbook issues.

- **Immediate revert logic:**  
  Quickly downgrading to Chef 16.13.16 (your stable version) minimizes risk of production outages, and lets you recover the system state if you encounter cookbook compilation errors.

- **Data transmission:**  
  Posting convergence status and logs to a central API enables centralized monitoring and retrospective analysis.

***

## **Potential Risks & Weaknesses**

- **Chef downgrades are not always seamless:**  
  Depending on installation method, config files, and dependency changes, downgrading may leave residual files, configs, or library mismatches.  
  - **Potential conflict:** Some resources (especially custom Ruby libraries, native gems, or platform packages) could be left in an inconsistent state.

- **No system state snapshot:**  
  If the Chef 18.5 run (even in dry-run) modifies any files accidentally or due to a bug, reverting Chef binaries isn’t enough—you may need to snapshot configs, resource states, or even perform a file system rollback.

- **Package management risks:**  
  Rapid repeated upgrades/downgrades could result in corrupted package states or configuration drift (especially if using distributions that don't gracefully handle RPM/DEB overrides).

- **Missing config backup/recovery:**  
  Critical config files (`client.rb`, trusted certificates, etc.) should be backed up before switching versions so they can be reverted alongside the software.

- **No integrity check:**  
  You do not currently check whether the re-downgraded node is returning exactly to the original working state.

***

## **Recommended Safety Enhancements (Python Additions):**

1. **Backup Configuration:**
   - Automatically copy relevant Chef and system config files to a backup folder before upgrading/downgrading Chef versions.
   - Restore these backups after downgrade.

2. **Verify Downgrade:**
   - After Chef 16.13.16 re-install, verify version and run a test converge with a basic recipe to confirm integrity.
   - Compare pre-upgrade and post-downgrade files (hashes, sizes) if practical.

3. **Roll-back Automation:**
   - Integrate OS-level snapshot, such as using LVM or btrfs/zfs if available, or trigger cloud VM snapshot APIs before running upgrades.

4. **Exception Handling & Recovery:**
   - Wrap each major action (upgrade, converge, log upload, downgrade) in `try/except` code.
   - If any error occurs, send an alert or notification (email, Slack, central API) with complete error details.
   - Abort remaining steps if integrity cannot be confirmed at any stage.

5. **Post-run Health Check:**
   - After reverting, run a designated “health check” recipe or script to ensure services/Chef run as expected.

6. **Chef Data and State Validation:**
   - Save and compare relevant `/var/chef/cache`, node attributes, and other Chef directories before and after tests.

7. **Clean-Up Logic:**
   - Clear Chef run history, temp files, or orphaned packages after downgrade to remove side effects of upgrade.

***

## **Example: Config Backup in Python**

```python
import shutil

def backup_chef_config(backup_dir='/tmp/chef_config_backup'):
    chef_config_files = ['/etc/chef/client.rb', '/etc/chef/validation.pem', '/etc/chef/client.pem']
    os.makedirs(backup_dir, exist_ok=True)
    for f in chef_config_files:
        if os.path.exists(f):
            shutil.copy(f, backup_dir)

def restore_chef_config(backup_dir='/tmp/chef_config_backup'):
    for f in os.listdir(backup_dir):
        shutil.copy(os.path.join(backup_dir, f), '/etc/chef/')
```

***

## **In Summary**

**Your workflow is a sound way to automate diagnostic testing for cookbook upgrades and reliably revert if necessary.**  
However, for robust safety in production, add backup, integrity validation, health checks, and clear exception handling.  
These additions ensure rapid, confident downgrade—and prevent any unintended changes or lingering issues after upgrade tests.

Sources
