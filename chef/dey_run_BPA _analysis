This requirement is ambitious but **absolutely feasible** with the right architecture. At this scale (100,000 nodes, team-based schedules, full dry-run analytics, logging, rollback data), you will need a robust reporting and orchestration system. Here’s a recommended approach for your **reporting UI and backend**:

***

## Key Components Needed

### 1. **Job Scheduler & Orchestrator**
- Use a scalable scheduler (e.g., Airflow, Celery, or a cloud-native job system) to handle scheduling, triggering, and tracking dry runs across distributed nodes.
- API endpoints for teams to submit schedules and query job status.

### 2. **Data Pipeline & Storage**
- Central DB (Postgres or similar, possibly sharded/partitioned for scale) to store:
  - Pre dry-run data (node config/state before run)
  - Dry-run results & logs (success/failure, full debug logs)
  - Rollback/final converge data and logs

### 3. **Reporting UI**
- Build a dashboard (React, Dash, or Flask+Jinja) with:
  - Scheduled runs: summary of scheduled dry runs per node/team/time
  - Status table: how many dry runs have happened, are scheduled, are in progress/implementation, with rich status (success/fail) and log access
  - Drill-down by node: pre-dry run config, dry-run results, rollback results/logs
  - Filtering/grouping by time, team, node, status
  - Downloadable logs and change reports

### 4. **Node Collector/Agent**
- Each node runs your modular Python agent, which:
  - Collects state before dry-run
  - Executes dry-run and captures logs/status
  - Rolls back and records post-rollback state/log
  - Returns all data to centralized API for ingestion

### 5. **API Backend**
- Endpoints to accept node results, status, logs
- Secure ingestion, scalable, retries/failure management
- User/team auth for report access

***

## Example Data Flow for One Node

1. **Pre-run:**  
   Agent pushes pre-run config/state to central API (`/api/node/pre_run/`)  
2. **Dry run:**  
   Executes dry run, sends debug log and status (`/api/node/dry_run/`)
3. **Rollback:**  
   Executes rollback, final converge, sends log/status (`/api/node/rollback`)
4. **Dashboard:**  
   Aggregates per node/team/cluster data, displays:
   - Scheduled runs
   - Completed runs (success/failure notation)
   - Access/download logs
   - Change diffs (before/after/rollback)

***

## Recommended Tech Stack

- **Scheduler:** Airflow, Celery, or Kubernetes Jobs
- **Agents:** Python scripts/modules
- **API & DB:** Python Flask/FastAPI + Postgres (possibly with partitioning)
- **Dashboard UI:** React, Dash (Plotly), or Flask+Jinja templates
- **Reporting/Notification:** Email, Slack, webhook integration on jobs

***

## Scaling & Reliability Notes

- Use **chunked/scheduled jobs** to avoid overwhelming infra/network
- Store node logs in cloud storage (S3, MinIO, etc.) if logs are large, only path in DB
- Use a messaging queue for node job status and log ingestion (Kafka, RabbitMQ) for resilience
- Implement RBAC for teams—each team sees only their nodes/jobs in the UI

***

## Summary Table for Every Node

| Node Name   | Scheduled | Dry Run Status | Log Access | Dry Run Data | Rollback Data | Final Status |
|-------------|-----------|---------------|------------|--------------|---------------|--------------|

All jobs (scheduled, in progress, complete) are tracked.  
**Drill-down for each node:** view pre-run data, dry-run logs, rollback logs, and final status.

***

**This pattern is standard for enterprise infra at scale!** You will want modular, scalable orchestration—Python agents for functional logic, a solid API/UI layer for reporting, and a reliable backend for jobs/logs.  
The architecture is extensible and ready for 100k+ nodes.

Sources
[1] Upgrade Lab: Chef Infra Client 12 to latest https://docs.chef.io/workstation/upgrade_lab/
[2] IT Automation and DevOps Dashboards - Chef Automate | Chef https://www.chef.io/products/chef-automate
[3] Chef by Convex | Generate realtime full‑stack apps https://chef.convex.dev
[4] How to use Chef Open Source : r/chef_opscode https://www.reddit.com/r/chef_opscode/comments/o68e56/how_to_use_chef_open_source/
[5] Open Source Chef vs Hosted Chef vs. On Premises Chef https://www.upguard.com/blog/chef-open-source-vs-hosted-chef-vs-on-premises-chef
[6] Job Scheduling With Flask: APScheduler, Cron Jobs And ... https://www.redwood.com/article/job-scheduling-with-flask/
[7] Chef Manage Configuration - YouTube https://www.youtube.com/watch?v=oejiYZ3LWjI
[8] Python provides convenience and flexibility for scalable ML/AI https://www.python.org/success-stories/python-provides-convenience-and-flexibility-for-scalable-mlai/
[9] Chef Dashboard https://www.datadoghq.com/dashboards/chef-dashboard/
[10] How to schedule a function to run every hour on Flask? https://stackoverflow.com/questions/21214270/how-to-schedule-a-function-to-run-every-hour-on-flask
[11] Chef Essentials: A Beginner's Guide to Infrastructure Automation https://www.exam-labs.com/blog/chef-essentials-a-beginners-guide-to-infrastructure-automation
[12] Scalable Network Automation with Python Generators https://networktocode.com/blog/2024-11-25-python-generators/
[13] Prometheus-Dashboard-Setup-and-Configuration.md https://github.com/chef/monitoring-integration-automate/blob/main/prometheus/Prometheus-Dashboard-Setup-and-Configuration.md
[14] 5 Python Libraries for Reporting and Factsheets - Xlwings https://www.xlwings.org/blog/reporting-with-python
